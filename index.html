<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tabulador de Debate Acad√©mico</title>

    <script>
      window.COMPANY_LOGO_URL = "./logo.jpg";
      window.COMPANY_NAME = "Learn By Talking Formaci√≥n";
      window.SUPABASE_URL = "https://paaatgxujyknjqdybanr.supabase.co";
      window.SUPABASE_KEY = "sb_publishable_p4Gql96nQ1GpoOxa7aGWwQ_Sm5AykJC";
    </script>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <!-- PDF -->
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>

    <style>
      :root {
        color-scheme: light;
        --brand: #930203;
        --brand-light: rgba(147,2,3,0.08);
        --brand-border: rgba(147,2,3,0.25);
        --bg: #f6f7fb;
        --card: #ffffff;
        --border: #e8e8ee;
        --muted: #666;
        --danger: #dc2626;
      }
      *, *::before, *::after { box-sizing: border-box; }
      body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:0; background:var(--bg); color:#111; font-size:14px; overflow-x:hidden; }
      header { background:var(--card); border-bottom:1px solid var(--border); padding:12px 16px; display:flex; gap:10px; align-items:center; justify-content:space-between; position:sticky; top:0; z-index:100; }
      .header-left { display:flex; align-items:center; gap:10px; min-width:0; }
      .brand-logo { width:40px; height:40px; object-fit:contain; border-radius:8px; border:1px solid #eee; background:#fff; padding:4px; flex-shrink:0; }
      h1 { font-size:15px; margin:0; color:var(--brand); white-space:nowrap; }
      .container { max-width:100%; width:100%; margin:0 auto; padding:14px 16px 40px; }
      .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:16px; box-shadow:0 1px 3px rgba(0,0,0,0.04); width:100%; overflow:hidden; }
      .toolbar { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
      .tabs { display:flex; gap:6px; flex-wrap:wrap; }
      .row { display:grid; gap:14px; }
      .row.cols2 { grid-template-columns:1fr 1fr; }
      .row.cols3 { grid-template-columns:1fr 1fr 1fr; }
      @media(max-width:700px){ .row.cols2,.row.cols3{grid-template-columns:1fr;} header{flex-wrap:wrap;} h1{font-size:13px;} }
      label { font-size:12px; display:block; margin-bottom:5px; color:var(--brand); font-weight:600; }
      input,select,textarea { width:100%; padding:9px 11px; border:1px solid #d9d9e3; border-radius:10px; background:#fff; color:#111; font-size:13px; outline:none; transition:border-color .15s; }
      input:focus,select:focus { border-color:var(--brand); }
      button { padding:9px 13px; border-radius:10px; border:1px solid #d9d9e3; background:white; cursor:pointer; color:var(--brand); font-size:13px; font-weight:500; white-space:nowrap; transition:all .15s; }
      button:hover { background:#f5f5f7; }
      button.primary { background:var(--brand); border-color:var(--brand); color:#fff; }
      button.primary:hover { background:#7a0102; }
      button.danger { background:var(--danger); border-color:var(--danger); color:#fff; }
      button.danger:hover { background:#b91c1c; }
      button.sm { padding:6px 10px; font-size:12px; }
      button:disabled { opacity:.5; cursor:not-allowed; }
      .tab { padding:8px 12px; border-radius:999px; border:1px solid #d9d9e3; background:white; font-size:12px; color:var(--brand); white-space:nowrap; }
      .tab.active { background:var(--brand-light); border-color:var(--brand-border); font-weight:600; }
      .table-wrap { width:100%; overflow-x:auto; -webkit-overflow-scrolling:touch; border-radius:8px; }
      table { width:100%; border-collapse:collapse; }
      th,td { border-bottom:1px solid #eee; padding:10px 8px; text-align:left; font-size:13px; vertical-align:top; }
      th { font-size:11px; color:var(--muted); font-weight:600; text-transform:uppercase; }
      .muted { color:var(--muted); }
      .small { font-size:12px; }
      .pill { display:inline-flex; align-items:center; padding:2px 8px; border-radius:999px; background:#f0f1f5; font-size:11px; color:#555; font-weight:500; }
      .pill.green { background:#d1fae5; color:#065f46; }
      .pill.orange { background:#fef3c7; color:#92400e; }
      .pill.blue { background:#dbeafe; color:#1d4ed8; }
      .spacer { height:10px; }
      .hr { height:1px; background:#eee; margin:12px 0; }
      .right { text-align:right; }
      .nowrap { white-space:nowrap; }
      .wrap { word-break:break-word; }
      code { background:#f0f1f5; padding:2px 6px; border-radius:6px; color:#111; font-size:12px; }
      .stack { display:grid; gap:8px; }
      .speakerRow { display:grid; grid-template-columns:1fr 180px 110px; gap:8px; align-items:center; }
      @media(max-width:700px){ .speakerRow{grid-template-columns:1fr;} table{display:block;overflow-x:auto;} }
      .round-header { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; padding:10px 12px; border:1px solid var(--border); border-radius:10px; cursor:pointer; transition:background .12s; background:#fff; margin-bottom:6px; }
      .round-header:hover { background:#fafafa; }
      .round-header.active { border-color:var(--brand-border); background:var(--brand-light); }
      .toast { border:1px solid var(--brand-border); background:rgba(147,2,3,0.04); border-radius:12px; padding:14px 16px; }
      .vs-badge { background:var(--brand); color:#fff; font-size:10px; font-weight:700; padding:2px 6px; border-radius:4px; flex-shrink:0; }
      .sync-badge { font-size:11px; padding:3px 8px; border-radius:999px; background:#d1fae5; color:#065f46; font-weight:600; }
      .sync-badge.loading { background:#e0e7ff; color:#3730a3; }
      .sync-badge.error { background:#fee2e2; color:#991b1b; }
      .error-box { background:#fef2f2; border:1px solid #fecaca; border-radius:10px; padding:12px 14px; color:#991b1b; font-size:13px; margin-bottom:12px; }
      .score-pair { display:flex; align-items:center; gap:6px; }
      .score-pair input { width:80px; min-width:0; padding:7px; text-align:center; }
      .score-sep { color:var(--muted); font-weight:700; }
    </style>
  </head>

  <body>
    <header>
      <div class="header-left">
        <img id="companyLogo" class="brand-logo" alt="Logo" />
        <div>
          <h1>Tabulador de Debate Acad√©mico</h1>
          <div id="companyName" class="muted small"></div>
        </div>
      </div>
      <div id="header-actions" class="toolbar"></div>
    </header>

    <div class="container"><div id="root"></div></div>

    <script type="text/babel">
      const { useEffect, useMemo, useState, useRef } = React;

      document.getElementById("companyLogo").src = window.COMPANY_LOGO_URL || "";
      document.getElementById("companyLogo").onerror = () => { document.getElementById("companyLogo").style.display="none"; };
      document.getElementById("companyName").textContent = "Un proyecto de " + (window.COMPANY_NAME || "Learn By Talking Formaci√≥n");

      // ===== SUPABASE (fetch directo, sin SDK) =====
      const SB = window.SUPABASE_URL;
      const KEY = window.SUPABASE_KEY;
      function hdr(extra={}) {
        return { "Content-Type":"application/json", apikey:KEY, Authorization:"Bearer "+KEY, Prefer:"return=representation", ...extra };
      }
      const db = {
        async getUser(email) {
          const r = await fetch(`${SB}/rest/v1/users?email=eq.${encodeURIComponent(email)}&limit=1`, { headers:hdr() });
          return (await r.json())?.[0] || null;
        },
        async createUser(u) {
          const r = await fetch(`${SB}/rest/v1/users`, { method:"POST", headers:hdr(), body:JSON.stringify(u) });
          if (!r.ok) { const e=await r.json(); throw new Error(e?.message||"Error al crear usuario"); }
          return (await r.json())?.[0];
        },
        async getTournaments(userId) {
          const r = await fetch(`${SB}/rest/v1/tournaments?user_id=eq.${userId}&order=last_modified.desc`, { headers:hdr() });
          if (!r.ok) throw new Error("Error al cargar torneos");
          return await r.json();
        },
        async upsertTournament(t) {
          const r = await fetch(`${SB}/rest/v1/tournaments`, {
            method:"POST",
            headers:hdr({ Prefer:"resolution=merge-duplicates,return=representation" }),
            body:JSON.stringify(t)
          });
          if (!r.ok) { const e=await r.json(); throw new Error(e?.message||"Error al guardar"); }
          return (await r.json())?.[0];
        },
        async deleteTournament(id) {
          const r = await fetch(`${SB}/rest/v1/tournaments?id=eq.${id}`, { method:"DELETE", headers:hdr() });
          if (!r.ok) throw new Error("Error al eliminar");
        }
      };

      function uid() { return Date.now()+""+Math.floor(Math.random()*1e6); }
      async function sha256(t) {
        const buf = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(t));
        return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
      }

      const ROLES = [
        {value:"Introductor",label:"Introductor"},
        {value:"Primer refutador",label:"Primer refutador"},
        {value:"Segundo refutador",label:"Segundo refutador"},
        {value:"Conclusor",label:"Conclusor"},
        {value:"Libre",label:"Libre (5¬∫ orador)"}
      ];
      const TIEBREAKS = [
        "Enfrentamiento directo > √çtems","√çtems > Enfrentamiento directo",
        "Enfrentamiento directo > √çtems > Votos","Enfrentamiento directo > Votos > √çtems",
        "√çtems > Enfrentamiento directo > Votos","√çtems > Votos > Enfrentamiento directo",
        "Votos > Enfrentamiento directo > √çtems","Votos > √çtems > Enfrentamiento directo"
      ];

      function App() {
        // Auth
        const [auth, setAuth] = useState(false);
        const [user, setUser] = useState(null);
        const [loginF, setLoginF] = useState({email:"",password:""});
        const [regF, setRegF] = useState({name:"",email:"",password:"",confirm:""});
        const [isReg, setIsReg] = useState(false);
        const [authErr, setAuthErr] = useState("");
        const [authLoad, setAuthLoad] = useState(false);

        // Sync
        const [sync, setSync] = useState("ok");
        const saveT = useRef(null);

        // Toast
        const [toast, setToast] = useState(null);
        function showToast(title, msg, ms=5500) {
          setToast({title,msg}); clearTimeout(window.__tt);
          window.__tt = setTimeout(()=>setToast(null),ms);
        }

        // State
        const [cfg, setCfg] = useState({
          tournamentName:"",
          roundsClasif:6,
          roundsFinales:4,
          tournamentSystem:"suizo",
          allowRepeatMatchups:false,
          numGroups:4,
          groupSize:4,
          speakersPerTeam:2,
          tiebreak:"√çtems > Enfrentamiento directo",
          sideAssignmentMode:"balanceado" // "balanceado" | "sin_asignar"
        });

        const [teams, setTeams] = useState([]);
        const [rounds, setRounds] = useState([]);
        const [curRound, setCurRound] = useState(0);
        const [groups, setGroups] = useState([]);
        const [rooms, setRooms] = useState([]);
        const [judges, setJudges] = useState([]);
        const [tournaments, setTournaments] = useState([]);
        const [tid, setTid] = useState(null);
        const [tab, setTab] = useState("torneos");
        const [editRnd, setEditRnd] = useState(null);
        const [rndTmp, setRndTmp] = useState("");

        const hasTournament = !!tid;

        useEffect(()=>{ if(auth && user) loadTournaments(); },[auth,user]);

        useEffect(()=>{
          if(!auth||!user||!tid) return;
          setSync("saving"); clearTimeout(saveT.current);
          saveT.current = setTimeout(()=>{ doSave().then(()=>setSync("ok")).catch(()=>setSync("error")); },1000);
        },[teams,rounds,rooms,judges,cfg,groups,curRound]);

        useEffect(()=>{
          const node = document.getElementById("header-actions");
          if(!node) return;
          const H = ()=>(
            <div className="toolbar">
              {auth ? (
                <>
                  {sync==="saving"&&<span className="sync-badge loading">üíæ Guardando‚Ä¶</span>}
                  {sync==="ok"&&<span className="sync-badge">‚òÅÔ∏è Guardado</span>}
                  {sync==="error"&&<span className="sync-badge error">‚ö† Error</span>}
                  <span className="small muted">üë§ {user?.name}</span>
                  <button className="primary sm" onClick={logout}>üö™ Salir</button>
                </>
              ):(<span className="small muted">No autenticado</span>)}
            </div>
          );
          ReactDOM.createRoot(node).render(<H/>);
        },[auth,user,sync]);

        // Speakers helpers
        function mkSpeakers(n) {
          const rs=["Introductor","Primer refutador","Segundo refutador","Conclusor","Libre"];
          return Array.from({length:n}).map((_,i)=>({id:uid()+i,name:"",role:rs[i]||"Libre",points:0}));
        }
        function normTeams(ts,n) {
          const c=Math.max(2,Math.min(5,Number(n||2)));
          return ts.map(t=>{
            const sp=[...(Array.isArray(t.speakers)?t.speakers:[])];
            if(sp.length<c) sp.push(...mkSpeakers(c-sp.length));
            else if(sp.length>c) sp.length=c;
            return {...t,speakers:sp};
          });
        }

        // Auth
        async function login() {
          setAuthErr(""); setAuthLoad(true);
          try {
            const email=loginF.email.trim().toLowerCase();
            const hash=await sha256(loginF.password);
            const u=await db.getUser(email);
            if(!u||u.password_hash!==hash){setAuthErr("Email o contrase√±a incorrectos");return;}
            setUser(u); setAuth(true); setLoginF({email:"",password:""});
          } catch(e){setAuthErr("Error de conexi√≥n: "+e.message);}
          finally{setAuthLoad(false);}
        }
        async function register() {
          setAuthErr(""); setAuthLoad(true);
          const name=regF.name.trim(), email=regF.email.trim().toLowerCase();
          if(!name){setAuthErr("Pon un nombre");setAuthLoad(false);return;}
          if(!email){setAuthErr("Pon un email");setAuthLoad(false);return;}
          if(regF.password!==regF.confirm){setAuthErr("Las contrase√±as no coinciden");setAuthLoad(false);return;}
          if(regF.password.length<6){setAuthErr("M√≠nimo 6 caracteres");setAuthLoad(false);return;}
          try {
            const ex=await db.getUser(email);
            if(ex){setAuthErr("Email ya registrado");return;}
            const nu={id:uid(),name,email,password_hash:await sha256(regF.password),created_at:new Date().toISOString()};
            await db.createUser(nu);
            setUser(nu); setAuth(true); setRegF({name:"",email:"",password:"",confirm:""}); setIsReg(false);
          } catch(e){setAuthErr("Error: "+e.message);}
          finally{setAuthLoad(false);}
        }
        function logout() {
          setAuth(false);setUser(null);setTournaments([]);setTid(null);
          resetData();setTab("torneos");setIsReg(false);setToast(null);setSync("ok");
        }

        // Persistence
        async function loadTournaments() {
          try { const rows=await db.getTournaments(user.id); setTournaments(rows||[]); } catch(e){console.error(e);}
        }
        async function doSave() {
          const row={id:tid,user_id:user.id,name:cfg.tournamentName||"Torneo sin nombre",data:JSON.stringify({cfg,teams,rounds,rooms,judges,groups,curRound}),last_modified:new Date().toISOString()};
          await db.upsertTournament(row);
          setTournaments(prev=>[row,...prev.filter(t=>t.id!==tid)]);
        }
        function openTournament(row) {
          const d=typeof row.data==="string"?JSON.parse(row.data):(row.data||{});
          setTid(row.id); setCfg(d.cfg||cfg);
          setTeams(normTeams(d.teams||[],d.cfg?.speakersPerTeam??2));
          setRounds(d.rounds||[]); setRooms(d.rooms||[]); setJudges(d.judges||[]);
          setGroups(d.groups||[]); setCurRound(d.curRound||0); setTab("config");
          showToast("‚úÖ Torneo cargado","Revisa ‚öôÔ∏è Config, luego üë• Equipos y genera üßæ Rondas.");
        }
        function newTournament() {
          setTid(uid()); resetData(); setTab("config");
          showToast("‚úÖ Torneo creado","Configura en ‚öôÔ∏è Config y a√±ade üë• Equipos.");
        }
        function resetData() {
          setCfg({
            tournamentName:"",
            roundsClasif:6,
            roundsFinales:4,
            tournamentSystem:"suizo",
            allowRepeatMatchups:false,
            numGroups:4,
            groupSize:4,
            speakersPerTeam:2,
            tiebreak:"√çtems > Enfrentamiento directo",
            sideAssignmentMode:"balanceado"
          });
          setTeams([]);setRounds([]);setRooms([]);setJudges([]);setGroups([]);setCurRound(0);
        }
        async function deleteTournament(id) {
          if(!confirm("¬øEliminar este torneo?")) return;
          try {
            await db.deleteTournament(id);
            setTournaments(prev=>prev.filter(t=>t.id!==id));
            if(tid===id){setTid(null);resetData();setTab("torneos");}
          } catch(e){alert("Error: "+e.message);}
        }

        // Teams
        function addTeam() {
          const n=Math.max(2,Math.min(5,Number(cfg.speakersPerTeam||2)));
          setTeams(normTeams([...teams,{id:uid(),name:`Equipo ${teams.length+1}`,school:"",speakers:mkSpeakers(n),points:0,itemsWon:0,votesWon:0,opponents:[],positions:{afavor:0,enContra:0}}],n));
        }
        function delTeam(id){setTeams(teams.filter(t=>t.id!==id));}
        function updTeam(id,f,v){setTeams(teams.map(t=>t.id===id?{...t,[f]:v}:t));}
        function updSpk(tid2,sid,f,v){setTeams(teams.map(t=>t.id!==tid2?t:{...t,speakers:(t.speakers||[]).map(s=>s.id===sid?{...s,[f]:v}:s)}));}

        // Rooms & Judges
        function addRoom(){setRooms([...rooms,{id:uid(),name:`Sala ${rooms.length+1}`,location:"",capacity:50,available:true}]);}
        function delRoom(id){setRooms(rooms.filter(r=>r.id!==id));}
        function updRoom(id,f,v){setRooms(rooms.map(r=>r.id===id?{...r,[f]:v}:r));}
        function addJudge(){setJudges([...judges,{id:uid(),name:`Juez ${judges.length+1}`,email:"",type:"principal",institution:"",experience:0,available:true,assignedMatches:[],conflictInstitutions:[]}]);}
        function delJudge(id){setJudges(judges.filter(j=>j.id!==id));}
        function updJudge(id,f,v){setJudges(judges.map(j=>j.id===id?{...j,[f]:v}:j));}

        // Excel
        function xlsxExport(data,sheet,file){const ws=XLSX.utils.json_to_sheet(data);const wb=XLSX.utils.book_new();XLSX.utils.book_append_sheet(wb,ws,sheet);XLSX.writeFile(wb,file);}
        function importExcel(e,cb){const f=e.target.files?.[0];if(!f)return;const r=new FileReader();r.onload=ev=>{const wb=XLSX.read(new Uint8Array(ev.target.result),{type:"array"});cb(XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]]));};r.readAsArrayBuffer(f);e.target.value="";}

        // Match helpers
        function getTeamIdsFromMatch(m){
          if(!m) return [null,null];
          if(m.sidesAssigned) return [m.aFavor, m.enContra];
          return [m.teamA, m.teamB];
        }

        function chooseSidesBalanced(t1, t2){
          const aF = Number(t1.positions?.afavor || 0);
          const aC = Number(t1.positions?.enContra || 0);
          const bF = Number(t2.positions?.afavor || 0);
          const bC = Number(t2.positions?.enContra || 0);

          const cost1 = Math.abs((aF+1)-aC) + Math.abs(bF-(bC+1)); // t1 favor, t2 contra
          const cost2 = Math.abs(aF-(aC+1)) + Math.abs((bF+1)-bC); // t2 favor, t1 contra

          if(cost2 < cost1) return { aFavor: t2.id, enContra: t1.id };
          if(cost1 < cost2) return { aFavor: t1.id, enContra: t2.id };
          return (Math.random() > 0.5) ? { aFavor: t1.id, enContra: t2.id } : { aFavor: t2.id, enContra: t1.id };
        }

        function makeMatch(t1, t2, extra = {}){
          if(cfg.sideAssignmentMode === "sin_asignar"){
            return {
              id: uid(),
              sidesAssigned: false,
              teamA: t1.id,
              teamB: t2.id,
              favorItems: null, contraItems: null,
              favorVotes: null, contraVotes: null,
              completed: false,
              ...extra
            };
          }
          const sides = chooseSidesBalanced(t1, t2);
          return {
            id: uid(),
            sidesAssigned: true,
            aFavor: sides.aFavor,
            enContra: sides.enContra,
            favorItems: null, contraItems: null,
            favorVotes: null, contraVotes: null,
            completed: false,
            ...extra
          };
        }

        function setMatchSides(ri, mi, favorId){
          setRounds(prev => prev.map((r,rIdx)=>{
            if(rIdx!==ri) return r;
            return {
              ...r,
              matches: (r.matches||[]).map((m,mIdx)=>{
                if(mIdx!==mi) return m;
                const [id1,id2] = getTeamIdsFromMatch(m);
                if(!id1 || !id2) return m;
                const other = (favorId === id1) ? id2 : id1;

                const nm = {
                  ...m,
                  sidesAssigned: true,
                  aFavor: favorId,
                  enContra: other,
                  favorItems: null, contraItems: null,
                  favorVotes: null, contraVotes: null,
                  completed: false
                };
                delete nm.teamA; delete nm.teamB;
                return nm;
              })
            };
          }));
        }

        // Groups core (evitar instituciones SIEMPRE)
        function schoolKey(s){
          const k = String(s||"").trim().toLowerCase();
          return k || "__sin__";
        }

        function roundRobinSchedule(teamIds){
          const list=[...teamIds];
          if(list.length%2===1) list.push(null);
          const n=list.length;
          const roundsCount=n-1;
          const half=n/2;
          const arr=[...list];
          const schedule=[];
          for(let r=0;r<roundsCount;r++){
            const pairs=[];
            for(let i=0;i<half;i++){
              const a=arr[i];
              const b=arr[n-1-i];
              if(a&&b)pairs.push([a,b]);
            }
            schedule.push(pairs);
            const fixed=arr[0];
            const rest=arr.slice(1);
            rest.unshift(rest.pop());
            arr.splice(0,arr.length,fixed,...rest);
          }
          return schedule;
        }

        function buildGroupsFixed(ts, numGroups){
          const n=Math.max(1,Number(numGroups||1));
          const gs=Array.from({length:n},(_,i)=>({id:i+1,name:`Grupo ${String.fromCharCode(65+i)}`,teams:[],schedule:[]}));

          const bySchool=new Map();
          for(const t of ts){
            const k=schoolKey(t.school);
            if(!bySchool.has(k))bySchool.set(k,[]);
            bySchool.get(k).push(t);
          }

          const buckets=Array.from(bySchool.values()).map(arr=>arr.sort(()=>Math.random()-.5));
          buckets.sort((a,b)=>b.length-a.length);

          for(const bucket of buckets){
            for(const team of bucket){
              const k=schoolKey(team.school);
              const candidates=gs
                .filter(g=>{
                  const members=g.teams.map(id=>ts.find(x=>x.id===id)).filter(Boolean);
                  return !members.some(m=>schoolKey(m.school)===k);
                })
                .sort((a,b)=>a.teams.length-b.teams.length);

              let target=candidates[0];
              if(!target){
                target=[...gs].sort((a,b)=>a.teams.length-b.teams.length)[0];
              }
              target.teams.push(team.id);
            }
          }

          for(const g of gs){
            g.schedule=roundRobinSchedule(g.teams);
          }
          return gs;
        }

        function buildGroupRoundMatches(gs, ts, roundIndex){
          const ms=[];
          for(const g of gs){
            const schedule=Array.isArray(g.schedule)?g.schedule:roundRobinSchedule(g.teams||[]);
            if(!schedule.length) continue;
            const pairs=schedule[roundIndex % schedule.length] || [];
            for(const [aId,bId] of pairs){
              const t1=ts.find(t=>t.id===aId);
              const t2=ts.find(t=>t.id===bId);
              if(!t1||!t2) continue;
              ms.push(makeMatch(t1, t2, { groupId:g.id }));
            }
          }
          return ms;
        }

        function ensureGroupsExist(){
          const n=Math.max(1,Number(cfg.numGroups||1));
          if(groups.length===n) return groups;
          const gs=Array.from({length:n},(_,i)=>({id:i+1,name:`Grupo ${String.fromCharCode(65+i)}`,teams:[],schedule:[]}));
          setGroups(gs);
          return gs;
        }

        function rebuildGroupsFromTeams(nextTeams, baseGroups){
          const n=Math.max(1,Number(cfg.numGroups||1));
          const base = (baseGroups && baseGroups.length) ? baseGroups : Array.from({length:n},(_,i)=>({id:i+1,name:`Grupo ${String.fromCharCode(65+i)}`,teams:[],schedule:[]}));
          const gs=base.map(g=>({id:g.id,name:g.name,teams:[],schedule:[]}));

          for(const t of nextTeams){
            if(!t.groupId) continue;
            const g=gs.find(x=>x.id===t.groupId);
            if(g) g.teams.push(t.id);
          }
          for(const g of gs){
            g.schedule=roundRobinSchedule(g.teams);
          }
          setGroups(gs);
        }

        function canPlaceTeamInGroup(teamId, groupId, nextTeams){
          if(!groupId) return true;
          const team = nextTeams.find(t=>t.id===teamId);
          if(!team) return false;
          const k = schoolKey(team.school);
          if(k==="__sin__") return true;
          const members = nextTeams.filter(t=>t.groupId===groupId && t.id!==teamId);
          return !members.some(m=>schoolKey(m.school)===k);
        }

        function setTeamGroup(teamId, newGroupId){
          const base = ensureGroupsExist();

          setTeams(prev=>{
            const next = prev.map(t=>t.id===teamId?{...t,groupId:newGroupId||null}:t);

            if(newGroupId && !canPlaceTeamInGroup(teamId, newGroupId, next)){
              alert("‚ùå No se puede: ya hay un equipo de la misma instituci√≥n en ese grupo.");
              return prev;
            }

            if(rounds.length>0){
              setRounds([]);
              setCurRound(0);
              showToast("‚ÑπÔ∏è Rondas reiniciadas","Al cambiar grupos, se borraron las rondas para evitar incoherencias.");
            }

            setTimeout(()=>rebuildGroupsFromTeams(next, base), 0);
            return next;
          });
        }

        // Stats
        const computed = useMemo(()=>{
          const ts=normTeams(teams,cfg.speakersPerTeam);
          const map=new Map();
          ts.forEach(t=>map.set(t.id,{...t,points:0,itemsWon:0,votesWon:0,opponents:[],positions:{afavor:0,enContra:0}}));

          for(const r of rounds) for(const m of (r.matches||[])){
            if(!m) continue;
            const [id1,id2] = getTeamIdsFromMatch(m);
            const A=map.get(id1), B=map.get(id2);
            if(!A||!B) continue;

            A.opponents=[...(A.opponents||[]),B.id];
            B.opponents=[...(B.opponents||[]),A.id];

            if(m.sidesAssigned){
              const Af = map.get(m.aFavor);
              const Bc = map.get(m.enContra);
              if(Af) Af.positions={...Af.positions,afavor:(Af.positions?.afavor||0)+1};
              if(Bc) Bc.positions={...Bc.positions,enContra:(Bc.positions?.enContra||0)+1};
            }

            if(!m.completed) continue;
            if(!m.sidesAssigned) continue;

            const aI=Number(m.favorItems),bI=Number(m.contraItems);
            const aV=m.favorVotes===null||m.favorVotes===""?null:Number(m.favorVotes);
            const bV=m.contraVotes===null||m.contraVotes===""?null:Number(m.contraVotes);

            const Fav = map.get(m.aFavor);
            const Con = map.get(m.enContra);
            if(!Fav || !Con) continue;

            if(Number.isFinite(aI)) Fav.itemsWon+=aI;
            if(Number.isFinite(bI)) Con.itemsWon+=bI;
            if(Number.isFinite(aV)) Fav.votesWon+=aV;
            if(Number.isFinite(bV)) Con.votesWon+=bV;

            if(aI>bI){Fav.points+=3;}
            else if(bI>aI){Con.points+=3;}
            else {Fav.points+=1; Con.points+=1;}
          }

          return Array.from(map.values());
        },[teams,rounds,cfg.speakersPerTeam,cfg.sideAssignmentMode]);

        function h2h(Aid,Bid){
          for(const r of rounds) for(const m of (r.matches||[])){
            if(!m?.completed) continue;
            if(!m.sidesAssigned) continue;
            const ab=(m.aFavor===Aid&&m.enContra===Bid)||(m.aFavor===Bid&&m.enContra===Aid);
            if(!ab) continue;

            const aI=Number(m.favorItems),bI=Number(m.contraItems);
            if(!Number.isFinite(aI)||!Number.isFinite(bI)) return 0;

            if(m.aFavor===Aid) return aI>bI?1:aI<bI?-1:0;
            else return bI>aI?1:bI<aI?-1:0;
          }
          return 0;
        }
        function cmp(a,b){
          if(b.points!==a.points)return b.points-a.points;
          for(const p of String(cfg.tiebreak||"√çtems > Enfrentamiento directo").split(">").map(x=>x.trim())){
            let v=0;
            if(p==="√çtems")v=b.itemsWon-a.itemsWon;
            else if(p==="Votos")v=b.votesWon-a.votesWon;
            else if(p==="Enfrentamiento directo")v=h2h(a.id,b.id)*-1;
            if(v!==0)return v;
          }
          return String(a.name||"").localeCompare(String(b.name||""));
        }
        const standings=useMemo(()=>[...computed].sort(cmp),[computed,rounds,cfg.tiebreak]);

        // Pairings
        function genPairings(){
          if(teams.length<2)return alert("Necesitas al menos 2 equipos");
          let ms=[];
          if(cfg.tournamentSystem==="suizo") ms=genSwiss();
          else if(cfg.tournamentSystem==="aleatorio") ms=genRandom();
          else ms=genGroups();

          ms=assignRJ(ms);
          const nr={
            number:rounds.length+1,
            name:`Ronda ${rounds.length+1}`,
            matches:ms,
            isClassificatory:rounds.length<Number(cfg.roundsClasif||0)
          };
          const newRounds=[...rounds,nr];
          setRounds(newRounds);
          setCurRound(newRounds.length-1);
          setTab("rondas");
        }

        function genSwiss(){
          const sorted=[...computed].sort(cmp);
          const ms=[];
          const paired=new Set();

          for(let i=0;i<sorted.length;i++){
            if(paired.has(sorted[i].id)) continue;
            for(let j=i+1;j<sorted.length;j++){
              if(paired.has(sorted[j].id)) continue;
              const t1=sorted[i], t2=sorted[j];
              if(!cfg.allowRepeatMatchups && (t1.opponents||[]).includes(t2.id)) continue;
              ms.push(makeMatch(t1,t2));
              paired.add(t1.id); paired.add(t2.id);
              break;
            }
          }
          return ms;
        }

        function genRandom(){
          const sh=[...teams].sort(()=>Math.random()-.5);
          const ms=[];
          for(let i=0;i<sh.length-1;i+=2){
            const t1=sh[i], t2=sh[i+1];
            if(!t1||!t2) continue;
            ms.push(makeMatch(t1,t2));
          }
          return ms;
        }

        function genGroups(){
          const n=Math.max(1,Number(cfg.numGroups||1));

          if(rounds.length===0 && groups.length===0){
            const shuffled=[...teams].sort(()=>Math.random()-.5);
            const ng=buildGroupsFixed(shuffled, n);

            const t2=shuffled.map(t=>{
              const g=ng.find(x=>x.teams.includes(t.id));
              return {...t, groupId:g?.id ?? null};
            });

            setGroups(ng);
            setTeams(t2);

            return buildGroupRoundMatches(ng, t2, 0);
          }

          return buildGroupRoundMatches(groups, teams, rounds.length);
        }

        function assignRJ(ms){
          const aR=rooms.filter(r=>r.available);
          const pJ=judges.filter(j=>j.available&&j.type==="principal");
          const panJ=judges.filter(j=>j.available&&j.type==="panelista");

          return ms.map((m,idx)=>{
            const [id1,id2] = getTeamIdsFromMatch(m);
            const t1 = teams.find(t=>t.id===id1);
            const t2 = teams.find(t=>t.id===id2);

            const ins=[t1?.school, t2?.school].filter(Boolean);
            const cf=j=>ins.includes(j.institution)||(j.conflictInstitutions||[]).some(i=>ins.includes(i));

            const room=aR.length?aR[idx%aR.length]:null;
            const asgn=[];

            const avP=pJ.filter(j=>!cf(j));
            const p=avP.length?avP[idx%avP.length]:pJ[idx%pJ.length];
            if(p)asgn.push({id:p.id,name:p.name,type:"principal",institution:p.institution});

            const avPan=panJ.filter(j=>!cf(j)&&!asgn.find(a=>a.id===j.id));
            for(let i=0;i<Math.min(2,avPan.length);i++){
              asgn.push({id:avPan[i].id,name:avPan[i].name,type:"panelista",institution:avPan[i].institution});
            }

            return {
              ...m,
              room: room ? {id:room.id,name:room.name,location:room.location} : null,
              judges: asgn
            };
          });
        }

        function updMatch(ri,mi,patch){
          setRounds(rounds.map((r,rIdx)=>{
            if(rIdx!==ri) return r;
            return {
              ...r,
              matches: (r.matches||[]).map((m,mIdx)=>{
                if(mIdx!==mi) return m;
                const n={...m,...patch};
                const okItems =
                  n.favorItems!==null && n.favorItems!=="" && Number.isFinite(Number(n.favorItems)) &&
                  n.contraItems!==null && n.contraItems!=="" && Number.isFinite(Number(n.contraItems));
                n.completed = !!n.sidesAssigned && okItems;
                return n;
              })
            };
          }));
        }

        // Round management
        function deleteRound(idx){
          if(!confirm(`¬øEliminar "${rounds[idx]?.name}"?`))return;
          const nr=rounds.filter((_,i)=>i!==idx);
          setRounds(nr);setCurRound(Math.max(0,Math.min(curRound,nr.length-1)));
        }
        function renameRound(idx,name){setRounds(rounds.map((r,i)=>i===idx?{...r,name}:r));setEditRnd(null);}
        function regenRound(idx){
          if(!confirm("¬øRegenerar emparejamientos? Se perder√°n los resultados."))return;
          let ms=[];
          if(cfg.tournamentSystem==="suizo") ms=genSwiss();
          else if(cfg.tournamentSystem==="aleatorio") ms=genRandom();
          else ms=genGroups();
          setRounds(rounds.map((r,i)=>i===idx?{...r,matches:assignRJ(ms)}:r));
        }
        function deleteMatch(ri,mi){
          if(!confirm("¬øEliminar este enfrentamiento?"))return;
          setRounds(rounds.map((r,rIdx)=>rIdx!==ri?r:{...r,matches:(r.matches||[]).filter((_,mIdx)=>mIdx!==mi)}));
        }

        function exportStandings(){
          xlsxExport(standings.map((t,i)=>({
            "Posici√≥n":i+1,
            "Equipo":t.name,
            "Instituci√≥n":t.school,
            "Puntos":t.points,
            "√çtems":t.itemsWon,
            "Votos":t.votesWon,
            "A favor":t.positions?.afavor||0,
            "En contra":t.positions?.enContra||0,
            "Oradores":(t.speakers||[]).map(s=>`${s.name||"-"} (${s.role||"-"})`).join(", ")
          })),"Clasificaci√≥n","clasificacion.xlsx");
        }

        // PDF
        function safeFileName(x){
          return String(x||"").replace(/[^\w\d\- ]+/g,"").trim().replace(/\s+/g,"_") || "archivo";
        }
        async function loadLogoDataUrl(url){
          if(!url) return null;
          return new Promise((resolve)=>{
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = ()=>{
              try{
                const canvas=document.createElement("canvas");
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx=canvas.getContext("2d");
                ctx.drawImage(img,0,0);
                let dataUrl = null;
                try { dataUrl = canvas.toDataURL("image/jpeg", 0.92); } catch(e) {}
                if(!dataUrl || !dataUrl.startsWith("data:image/")) {
                  try { dataUrl = canvas.toDataURL("image/png"); } catch(e) {}
                }
                resolve(dataUrl || null);
              }catch(e){ resolve(null); }
            };
            img.onerror = ()=>resolve(null);
            img.src = url;
          });
        }
        async function exportRoundPDF(roundIndex){
          const r = rounds[roundIndex];
          if(!r) return;

          const { jsPDF } = window.jspdf;
          const doc = new jsPDF({ unit:"pt", format:"a4" });

          const margin = 40;
          const pageW = doc.internal.pageSize.getWidth();
          const pageH = doc.internal.pageSize.getHeight();

          doc.setFont("helvetica","bold");
          doc.setFontSize(16);
          doc.text(cfg.tournamentName || "Torneo", margin, 50);

          doc.setFont("helvetica","normal");
          doc.setFontSize(12);
          doc.text(r.name || `Ronda ${r.number}`, margin, 72);

          const created = new Date().toLocaleString();
          doc.setFontSize(10);
          doc.setTextColor(100);
          doc.text(`Generado: ${created}`, margin, 88);
          doc.setTextColor(0);

          const logoDataUrl = await loadLogoDataUrl(window.COMPANY_LOGO_URL);
          if(logoDataUrl){
            try{
              const maxH = 36, maxW = 120;
              doc.addImage(logoDataUrl, logoDataUrl.includes("image/png") ? "PNG" : "JPEG", pageW - margin - maxW, 34, maxW, maxH);
            }catch(e){}
          }

          const rows = (r.matches||[]).map((m,i)=>{
            const [id1,id2] = getTeamIdsFromMatch(m);
            const t1 = teams.find(t=>t.id===id1);
            const t2 = teams.find(t=>t.id===id2);

            let enfrentamiento = "";
            if(m.sidesAssigned){
              const fav = teams.find(t=>t.id===m.aFavor);
              const con = teams.find(t=>t.id===m.enContra);
              enfrentamiento = `${fav?.name||"‚Äî"} (A FAVOR) vs ${con?.name||"‚Äî"} (EN CONTRA)`;
            } else {
              enfrentamiento = `${t1?.name||"‚Äî"} vs ${t2?.name||"‚Äî"} (Lados por sortear)`;
            }

            const sala = m.room?.name ? `${m.room.name}${m.room.location?` ¬∑ ${m.room.location}`:""}` : "‚Äî";
            const jueces = (m.judges||[]).length ? (m.judges||[]).map(j=>j.name).join(", ") : "‚Äî";

            return [`Mesa ${i+1}`, enfrentamiento, sala, jueces];
          });

          doc.autoTable({
            startY: 110,
            head: [["Mesa","Enfrentamiento","Sala","Jueces"]],
            body: rows,
            styles: { font:"helvetica", fontSize:9, cellPadding:6, overflow:"linebreak" },
            headStyles: { fillColor: [147, 2, 3], textColor: 255 },
            columnStyles: { 0:{cellWidth:60}, 1:{cellWidth:260}, 2:{cellWidth:110}, 3:{cellWidth:110} },
            margin: { left: margin, right: margin }
          });

          doc.setFontSize(9);
          doc.setTextColor(120);
          doc.text(`${window.COMPANY_NAME || ""}`, margin, pageH - 30);
          doc.setTextColor(0);

          const safeName = safeFileName(cfg.tournamentName || "torneo");
          const safeRound = safeFileName(r.name || `ronda_${r.number}`);
          doc.save(`${safeName}_${safeRound}.pdf`);
        }

        function Tab({id,children}){
          return (
            <button
              className={"tab "+(tab===id?"active":"")}
              onClick={()=>setTab(id)}
              disabled={!auth||(!hasTournament&&id!=="torneos")}
              title={!hasTournament&&id!=="torneos"?"Crea o carga un torneo primero":""}
            >
              {children}
            </button>
          );
        }

        // Auth screen
        if(!auth) return (
          <div className="card">
            <h2 style={{marginTop:0}}>Acceso</h2>
            <div className="tabs" style={{marginBottom:14}}>
              <button className={"tab "+(!isReg?"active":"")} onClick={()=>{setIsReg(false);setAuthErr("");}}>Iniciar sesi√≥n</button>
              <button className={"tab "+(isReg?"active":"")} onClick={()=>{setIsReg(true);setAuthErr("");}}>Crear cuenta</button>
            </div>
            {authErr&&<div className="error-box">‚ö†Ô∏è {authErr}</div>}
            {isReg?(
              <div className="row cols2">
                <div><label>Nombre</label><input value={regF.name} onChange={e=>setRegF({...regF,name:e.target.value})}/></div>
                <div><label>Email</label><input type="email" value={regF.email} onChange={e=>setRegF({...regF,email:e.target.value})}/></div>
                <div><label>Contrase√±a</label><input type="password" value={regF.password} onChange={e=>setRegF({...regF,password:e.target.value})}/></div>
                <div><label>Confirmar contrase√±a</label><input type="password" value={regF.confirm} onChange={e=>setRegF({...regF,confirm:e.target.value})}/></div>
                <div style={{gridColumn:"1/-1"}}><button className="primary" onClick={register} disabled={authLoad}>{authLoad?"Creando‚Ä¶":"Crear cuenta"}</button></div>
              </div>
            ):(
              <div className="row cols2">
                <div><label>Email</label><input type="email" value={loginF.email} onChange={e=>setLoginF({...loginF,email:e.target.value})} onKeyDown={e=>e.key==="Enter"&&login()}/></div>
                <div><label>Contrase√±a</label><input type="password" value={loginF.password} onChange={e=>setLoginF({...loginF,password:e.target.value})} onKeyDown={e=>e.key==="Enter"&&login()}/></div>
                <div style={{gridColumn:"1/-1"}}><button className="primary" onClick={login} disabled={authLoad}>{authLoad?"Entrando‚Ä¶":"Entrar"}</button></div>
              </div>
            )}
            <div className="hr"></div>
            <p className="muted small">‚òÅÔ∏è Los datos se guardan en Supabase y son accesibles desde cualquier dispositivo con tu cuenta.</p>
            <p className="muted small" style={{marginBottom:0}}><b>Un proyecto de {window.COMPANY_NAME||"Learn By Talking Formaci√≥n"}</b></p>
          </div>
        );

        // Main app
        return (
          <div className="row" style={{gap:12}}>
            <div className="card" style={{padding:"12px 14px"}}>
              <div className="toolbar" style={{justifyContent:"space-between"}}>
                <div className="tabs">
                  <Tab id="torneos">üèÜ Torneos</Tab>
                  <Tab id="config">‚öôÔ∏è Config</Tab>
                  <Tab id="equipos">üë• Equipos</Tab>
                  {cfg.tournamentSystem==="grupos" && <Tab id="grupos">üì¶ Grupos</Tab>}
                  <Tab id="salas">üè´ Salas</Tab>
                  <Tab id="jueces">üßë‚Äç‚öñÔ∏è Jueces</Tab>
                  <Tab id="rondas">üßæ Rondas</Tab>
                  <Tab id="ranking">üìä Ranking</Tab>
                </div>
                <button className="primary sm" onClick={newTournament}>‚ûï Nuevo torneo</button>
              </div>
            </div>

            {toast&&(
              <div className="toast">
                <div style={{display:"flex",justifyContent:"space-between",gap:10,alignItems:"flex-start",flexWrap:"wrap"}}>
                  <div><div style={{fontWeight:700,marginBottom:4}}>{toast.title}</div><div className="muted small">{toast.msg}</div></div>
                  <button className="primary sm" onClick={()=>setToast(null)}>‚úï</button>
                </div>
              </div>
            )}

            {/* TORNEOS */}
            {tab==="torneos"&&(
              <div className="card">
                <h2 style={{marginTop:0}}>Tus torneos</h2>
                <div className="muted small" style={{marginBottom:12}}>‚òÅÔ∏è Guardados en Supabase ‚Äî accesibles desde cualquier dispositivo.</div>
                {tournaments.length===0?<div className="muted">No hay torneos. Pulsa "Nuevo torneo".</div>:(
                  <div className="table-wrap">
                    <table>
                      <thead><tr><th>Nombre</th><th>√öltima edici√≥n</th><th className="right">Acciones</th></tr></thead>
                      <tbody>
                        {tournaments.map(t=>{
                          const d=typeof t.data==="string"?JSON.parse(t.data):(t.data||{});
                          return(
                            <tr key={t.id}>
                              <td className="wrap">
                                <div style={{display:"flex",gap:8,alignItems:"center",flexWrap:"wrap"}}>
                                  <b>{t.name}</b>{tid===t.id&&<span className="pill blue">abierto</span>}
                                </div>
                                <div className="muted small">Equipos: {d.teams?.length||0} ¬∑ Rondas: {d.rounds?.length||0}</div>
                              </td>
                              <td className="nowrap muted small">{t.last_modified?new Date(t.last_modified).toLocaleString():"-"}</td>
                              <td className="right nowrap">
                                <button className="primary sm" onClick={()=>openTournament(t)}>Abrir</button>{" "}
                                <button className="danger sm" onClick={()=>deleteTournament(t.id)}>üóëÔ∏è</button>
                              </td>
                            </tr>
                          );
                        })}
                      </tbody>
                    </table>
                  </div>
                )}
              </div>
            )}

            {/* CONFIG */}
            {tab==="config"&&(
              <div className="card">
                <h2 style={{marginTop:0}}>Configuraci√≥n</h2>
                <div className="row cols3">
                  <div><label>Nombre del torneo</label><input value={cfg.tournamentName} onChange={e=>setCfg({...cfg,tournamentName:e.target.value})}/></div>

                  <div><label>Sistema</label>
                    <select
                      value={cfg.tournamentSystem}
                      onChange={e=>{
                        const next = e.target.value;
                        setCfg({...cfg,tournamentSystem:next});
                        if(next!=="grupos"){
                          setGroups([]);
                          setTeams(prev=>prev.map(t=>{ const nt={...t}; delete nt.groupId; return nt; }));
                          if(tab==="grupos") setTab("config");
                        }
                      }}
                    >
                      <option value="suizo">Suizo</option>
                      <option value="aleatorio">Aleatorio</option>
                      <option value="grupos">Grupos</option>
                    </select>
                  </div>

                  <div><label>Permitir repetici√≥n</label>
                    <select value={String(cfg.allowRepeatMatchups)} onChange={e=>setCfg({...cfg,allowRepeatMatchups:e.target.value==="true"})}>
                      <option value="false">No</option><option value="true">S√≠</option>
                    </select>
                  </div>

                  <div>
                    <label>Asignaci√≥n A favor / En contra</label>
                    <select
                      value={cfg.sideAssignmentMode}
                      onChange={e=>setCfg({...cfg, sideAssignmentMode: e.target.value })}
                    >
                      <option value="balanceado">Autom√°tica (balanceada)</option>
                      <option value="sin_asignar">No asignar (se sortea fuera)</option>
                    </select>
                  </div>

                  <div><label>N¬∫ oradores por equipo (2‚Äì5)</label>
                    <select value={String(cfg.speakersPerTeam)} onChange={e=>{const v=Math.max(2,Math.min(5,Number(e.target.value)));setCfg({...cfg,speakersPerTeam:v});setTeams(prev=>normTeams(prev,v));}}>
                      {[2,3,4,5].map(n=><option key={n} value={n}>{n}</option>)}
                    </select>
                  </div>

                  <div style={{gridColumn:"span 2"}}><label>Criterio de desempate</label>
                    <select value={cfg.tiebreak} onChange={e=>setCfg({...cfg,tiebreak:e.target.value})}>
                      {TIEBREAKS.map(o=><option key={o} value={o}>{o}</option>)}
                    </select>
                  </div>

                  {cfg.tournamentSystem==="grupos"&&<>
                    <div><label>N¬∫ de grupos</label><input type="number" value={cfg.numGroups} onChange={e=>{
                      const v=Math.max(1,Number(e.target.value||1));
                      setCfg({...cfg,numGroups:v});
                      setGroups([]);
                      setTeams(prev=>prev.map(t=>{ const nt={...t}; delete nt.groupId; return nt; }));
                      setRounds([]); setCurRound(0);
                      showToast("‚ÑπÔ∏è Grupos reiniciados","Cambiando el n√∫mero de grupos se reinici√≥ la fase de grupos.");
                    }}/></div>
                    <div><label>Tama√±o grupo (informativo)</label><input type="number" value={cfg.groupSize} onChange={e=>setCfg({...cfg,groupSize:Number(e.target.value)})}/></div>

                    <div style={{gridColumn:"span 3"}} className="toast">
                      <b>Regla activa:</b> la asignaci√≥n autom√°tica de grupos siempre intenta evitar que dos equipos de la misma instituci√≥n caigan en el mismo grupo.
                      <div className="muted small" style={{marginTop:6}}>
                        Si una instituci√≥n tiene m√°s equipos que grupos, puede ser imposible evitarlo al 100%.
                      </div>
                    </div>
                  </>}
                </div>
                <div className="hr"></div>
                <div className="toolbar" style={{justifyContent:"flex-end"}}>
                  <button className="primary" onClick={genPairings} disabled={computed.length<2}>üß© Generar emparejamientos (nueva ronda)</button>
                </div>
              </div>
            )}

            {/* EQUIPOS */}
            {tab==="equipos"&&(
              <div className="card">
                <div className="toolbar" style={{justifyContent:"space-between"}}>
                  <h2 style={{margin:0}}>Equipos</h2>
                  <button className="primary" onClick={addTeam}>‚ûï A√±adir equipo</button>
                </div>
                <div className="spacer"></div>
                {teams.length===0?<div className="muted">No hay equipos.</div>:(
                  <div className="table-wrap"><table>
                    <thead><tr><th>Equipo</th><th>Instituci√≥n</th><th>Oradores</th><th className="right">Acc.</th></tr></thead>
                    <tbody>
                      {normTeams(teams,cfg.speakersPerTeam).map(t=>(
                        <tr key={t.id}>
                          <td style={{minWidth:130}}><input value={t.name} onChange={e=>updTeam(t.id,"name",e.target.value)}/></td>
                          <td style={{minWidth:130}}><input value={t.school} onChange={e=>updTeam(t.id,"school",e.target.value)}/></td>
                          <td style={{minWidth:340}}>
                            <div className="stack">
                              {(t.speakers||[]).map((s,i)=>(
                                <div className="speakerRow" key={s.id}>
                                  <input placeholder={`Orador ${i+1}`} value={s.name||""} onChange={e=>updSpk(t.id,s.id,"name",e.target.value)}/>
                                  <select value={s.role||"Libre"} onChange={e=>updSpk(t.id,s.id,"role",e.target.value)}>{ROLES.map(r=><option key={r.value} value={r.value}>{r.label}</option>)}</select>
                                  <input type="number" placeholder="Puntos" value={String(s.points??0)} onChange={e=>updSpk(t.id,s.id,"points",Number(e.target.value))}/>
                                </div>
                              ))}
                            </div>
                          </td>
                          <td className="right"><button className="danger sm" onClick={()=>delTeam(t.id)}>üóëÔ∏è</button></td>
                        </tr>
                      ))}
                    </tbody>
                  </table></div>
                )}
              </div>
            )}

            {/* GRUPOS */}
            {tab==="grupos" && cfg.tournamentSystem==="grupos" && (
              <div className="card">
                <div className="toolbar" style={{justifyContent:"space-between"}}>
                  <h2 style={{margin:0}}>Grupos</h2>
                  <div className="toolbar">
                    <button
                      className="sm"
                      onClick={()=>{
                        if(teams.length<2) return alert("A√±ade equipos primero.");
                        const shuffled=[...teams].sort(()=>Math.random()-.5);
                        const ng=buildGroupsFixed(shuffled, cfg.numGroups);
                        const t2=shuffled.map(t=>{
                          const g=ng.find(x=>x.teams.includes(t.id));
                          return {...t, groupId:g?.id ?? null};
                        });
                        setTeams(t2);
                        setGroups(ng);
                        if(rounds.length>0){
                          setRounds([]); setCurRound(0);
                          showToast("‚ÑπÔ∏è Rondas reiniciadas","Al regenerar grupos, se borraron las rondas.");
                        }
                        showToast("‚úÖ Grupos generados","Puedes editar manualmente (se bloquear√° si rompe instituciones).");
                      }}
                    >
                      üé≤ Generar grupos autom√°tico
                    </button>

                    <button
                      className="sm"
                      onClick={()=>{
                        if(!confirm("Esto quitar√° a todos los equipos de los grupos y borrar√° rondas. ¬øContinuar?")) return;
                        const next=teams.map(t=>{ const nt={...t}; delete nt.groupId; return nt; });
                        setTeams(next);
                        setGroups([]);
                        setRounds([]); setCurRound(0);
                        showToast("üßπ Grupos vaciados","Ahora puedes asignar equipos manualmente.");
                      }}
                    >
                      üßπ Vaciar
                    </button>
                  </div>
                </div>

                <div className="spacer"></div>

                <div className="toast" style={{marginBottom:12}}>
                  <b>Regla:</b> no se permite mover un equipo a un grupo donde ya exista otro equipo de la misma instituci√≥n.
                </div>

                <div className="card" style={{padding:14}}>
                  <h3 style={{marginTop:0}}>Asignaci√≥n manual</h3>
                  <div className="muted small" style={{marginBottom:10}}>
                    Si cambias asignaciones, se reinician las rondas autom√°ticamente para evitar emparejamientos incoherentes.
                  </div>

                  <div className="table-wrap">
                    <table>
                      <thead>
                        <tr>
                          <th>Equipo</th>
                          <th>Instituci√≥n</th>
                          <th style={{width:240}}>Grupo</th>
                        </tr>
                      </thead>
                      <tbody>
                        {teams.slice().sort((a,b)=>String(a.name||"").localeCompare(String(b.name||""))).map(t=>(
                          <tr key={t.id}>
                            <td className="wrap"><b>{t.name||"‚Äî"}</b></td>
                            <td className="wrap muted">{t.school||"‚Äî"}</td>
                            <td>
                              <select
                                value={String(t.groupId||"")}
                                onChange={e=>{
                                  const val=e.target.value?Number(e.target.value):null;
                                  setTeamGroup(t.id, val);
                                }}
                              >
                                <option value="">(Sin grupo)</option>
                                {ensureGroupsExist().map(g=>(
                                  <option key={g.id} value={String(g.id)}>{g.name}</option>
                                ))}
                              </select>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>

                <div className="hr"></div>

                <div className="toolbar" style={{justifyContent:"space-between"}}>
                  <h3 style={{margin:0}}>Vista de grupos</h3>
                  <button
                    className="sm"
                    onClick={()=>{
                      const base=ensureGroupsExist();
                      rebuildGroupsFromTeams(teams, base);
                      showToast("üîÑ Actualizado","Se recalcul√≥ el calendario interno de cada grupo.");
                    }}
                  >
                    üîÑ Recalcular calendario
                  </button>
                </div>

                <div className="spacer"></div>

                {groups.length===0 ? (
                  <div className="muted">A√∫n no hay grupos creados. Pulsa ‚Äúüé≤ Generar grupos autom√°tico‚Äù o asigna equipos manualmente.</div>
                ) : (
                  <div className="row cols2">
                    {groups.map(g=>{
                      const gTeams=teams.filter(t=>t.groupId===g.id).sort((a,b)=>String(a.name||"").localeCompare(String(b.name||"")));
                      return (
                        <div key={g.id} className="card" style={{padding:14}}>
                          <div style={{display:"flex",justifyContent:"space-between",gap:10,flexWrap:"wrap"}}>
                            <div>
                              <div style={{display:"flex",gap:8,alignItems:"center",flexWrap:"wrap"}}>
                                <h3 style={{margin:"0 0 4px 0"}}>{g.name}</h3>
                                <span className="pill">{gTeams.length} equipos</span>
                              </div>
                              <div className="muted small">Calendario interno: {Array.isArray(g.schedule)?g.schedule.length:0} rondas</div>
                            </div>
                          </div>

                          <div className="hr"></div>

                          {gTeams.length===0 ? (
                            <div className="muted">Sin equipos.</div>
                          ) : (
                            <div className="table-wrap">
                              <table>
                                <thead><tr><th>Equipo</th><th>Instituci√≥n</th></tr></thead>
                                <tbody>
                                  {gTeams.map(t=>(
                                    <tr key={t.id}>
                                      <td className="wrap"><b>{t.name||"‚Äî"}</b></td>
                                      <td className="wrap muted">{t.school||"‚Äî"}</td>
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          )}
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            )}

            {/* SALAS */}
            {tab==="salas"&&(
              <div className="card">
                <div className="toolbar" style={{justifyContent:"space-between"}}>
                  <h2 style={{margin:0}}>Salas</h2>
                  <div className="toolbar">
                    <button onClick={()=>xlsxExport([{Nombre:"Sala 1",Ubicaci√≥n:"Edificio A",Capacidad:50}],"Salas","plantilla_salas.xlsx")}>‚¨áÔ∏è Plantilla</button>
                    <label className="tab" style={{cursor:"pointer"}}>‚¨ÜÔ∏è Importar<input type="file" accept=".xlsx,.xls" onChange={e=>importExcel(e,json=>setRooms(prev=>[...prev,...json.map((r,i)=>({id:uid()+i,name:r["Nombre"]||`Sala ${i+1}`,location:r["Ubicaci√≥n"]||"",capacity:Number(r["Capacidad"]||50),available:true}))]))} style={{display:"none"}}/></label>
                    <button className="primary" onClick={addRoom}>‚ûï A√±adir</button>
                  </div>
                </div>
                <div className="spacer"></div>
                {rooms.length===0?<div className="muted">No hay salas.</div>:(
                  <div className="table-wrap"><table>
                    <thead><tr><th>Nombre</th><th>Ubicaci√≥n</th><th>Capacidad</th><th>Disponible</th><th className="right">Acc.</th></tr></thead>
                    <tbody>{rooms.map(r=>(
                      <tr key={r.id}>
                        <td><input value={r.name} onChange={e=>updRoom(r.id,"name",e.target.value)}/></td>
                        <td><input value={r.location} onChange={e=>updRoom(r.id,"location",e.target.value)}/></td>
                        <td style={{width:120}}><input type="number" value={r.capacity} onChange={e=>updRoom(r.id,"capacity",Number(e.target.value))}/></td>
                        <td style={{width:110}}><select value={String(r.available)} onChange={e=>updRoom(r.id,"available",e.target.value==="true")}><option value="true">S√≠</option><option value="false">No</option></select></td>
                        <td className="right"><button className="danger sm" onClick={()=>delRoom(r.id)}>üóëÔ∏è</button></td>
                      </tr>
                    ))}</tbody>
                  </table></div>
                )}
              </div>
            )}

            {/* JUECES */}
            {tab==="jueces"&&(
              <div className="card">
                <div className="toolbar" style={{justifyContent:"space-between"}}>
                  <h2 style={{margin:0}}>Jueces</h2>
                  <div className="toolbar">
                    <button onClick={()=>xlsxExport([{Nombre:"Juan P√©rez",Email:"juan@email.com",Tipo:"principal",Instituci√≥n:"Univ A",Experiencia:5}],"Jueces","plantilla_jueces.xlsx")}>‚¨áÔ∏è Plantilla</button>
                    <label className="tab" style={{cursor:"pointer"}}>‚¨ÜÔ∏è Importar<input type="file" accept=".xlsx,.xls" onChange={e=>importExcel(e,json=>setJudges(prev=>[...prev,...json.map((r,i)=>({id:uid()+i,name:r["Nombre"]||`Juez ${i+1}`,email:r["Email"]||"",type:String(r["Tipo"]||"principal").toLowerCase(),institution:r["Instituci√≥n"]||"",experience:Number(r["Experiencia"]||0),available:true,assignedMatches:[],conflictInstitutions:[]}))]))} style={{display:"none"}}/></label>
                    <button className="primary" onClick={addJudge}>‚ûï A√±adir</button>
                  </div>
                </div>
                <div className="spacer"></div>
                {judges.length===0?<div className="muted">No hay jueces.</div>:(
                  <div className="table-wrap"><table>
                    <thead><tr><th>Nombre</th><th>Email</th><th>Tipo</th><th>Instituci√≥n</th><th>Disponible</th><th className="right">Acc.</th></tr></thead>
                    <tbody>{judges.map(j=>(
                      <tr key={j.id}>
                        <td><input value={j.name} onChange={e=>updJudge(j.id,"name",e.target.value)}/></td>
                        <td><input value={j.email} onChange={e=>updJudge(j.id,"email",e.target.value)}/></td>
                        <td style={{width:130}}><select value={j.type} onChange={e=>updJudge(j.id,"type",e.target.value)}><option value="principal">principal</option><option value="panelista">panelista</option></select></td>
                        <td><input value={j.institution} onChange={e=>updJudge(j.id,"institution",e.target.value)}/></td>
                        <td style={{width:110}}><select value={String(j.available)} onChange={e=>updJudge(j.id,"available",e.target.value==="true")}><option value="true">S√≠</option><option value="false">No</option></select></td>
                        <td className="right"><button className="danger sm" onClick={()=>delJudge(j.id)}>üóëÔ∏è</button></td>
                      </tr>
                    ))}</tbody>
                  </table></div>
                )}
              </div>
            )}

            {/* RONDAS */}
            {tab==="rondas"&&(
              <div className="card">
                <div className="toolbar" style={{justifyContent:"space-between"}}>
                  <h2 style={{margin:0}}>Rondas</h2>
                  <div className="toolbar">
                    <button className="primary" onClick={genPairings} disabled={computed.length<2}>‚ûï Nueva ronda</button>
                    <button className="sm" onClick={()=>{ if(rounds.length===0) return alert("No hay rondas."); exportRoundPDF(curRound); }}>
                      üìÑ PDF (ronda)
                    </button>
                    <span className="muted small">Total: {rounds.length}</span>
                  </div>
                </div>

                <div className="spacer"></div>

                {rounds.length===0?<div className="muted">No hay rondas. Pulsa "Nueva ronda".</div>:(
                  <>
                    <div className="stack" style={{marginBottom:12}}>
                      {rounds.map((r,idx)=>{
                        const comp=(r.matches||[]).filter(m=>m.completed).length;
                        const tot=(r.matches||[]).length;
                        return(
                          <div key={idx} className={"round-header "+(curRound===idx?"active":"")} onClick={()=>setCurRound(idx)}>
                            <div style={{display:"flex",alignItems:"center",gap:10,flexWrap:"wrap"}}>
                              {editRnd===idx?(
                                <input autoFocus value={rndTmp} style={{width:160,padding:"4px 8px",fontSize:13,borderRadius:8}}
                                  onClick={e=>e.stopPropagation()}
                                  onChange={e=>setRndTmp(e.target.value)}
                                  onKeyDown={e=>{if(e.key==="Enter")renameRound(idx,rndTmp);if(e.key==="Escape")setEditRnd(null);}}
                                />
                              ):<b>{r.name||`Ronda ${r.number}`}</b>}
                              <span className={"pill "+(comp===tot&&tot>0?"green":comp>0?"orange":"")}>{comp}/{tot} completados</span>
                              {r.isClassificatory&&<span className="pill">Clasificatoria</span>}
                            </div>
                            <div className="toolbar" onClick={e=>e.stopPropagation()}>
                              {editRnd===idx?(
                                <><button className="primary sm" onClick={()=>renameRound(idx,rndTmp)}>‚úì</button><button className="sm" onClick={()=>setEditRnd(null)}>‚úï</button></>
                              ):(
                                <><button className="sm" onClick={()=>{setEditRnd(idx);setRndTmp(r.name||`Ronda ${r.number}`);}}>‚úèÔ∏è</button><button className="sm" onClick={()=>regenRound(idx)}>üîÑ</button><button className="danger sm" onClick={()=>deleteRound(idx)}>üóëÔ∏è Borrar</button></>
                              )}
                            </div>
                          </div>
                        );
                      })}
                    </div>

                    <div className="hr"></div>

                    {rounds[curRound]&&(
                      <>
                        <div className="toolbar" style={{justifyContent:"space-between",marginBottom:12}}>
                          <h3 style={{margin:0}}>{rounds[curRound]?.name||`Ronda ${rounds[curRound]?.number}`}</h3>
                          <span className="muted small">
                            Lados: <b>{cfg.sideAssignmentMode==="balanceado" ? "Autom√°tica (balanceada)" : "No asignar (se sortea fuera)"}</b> ¬∑ Desempate: <b>{cfg.tiebreak}</b>
                          </span>
                        </div>

                        <div className="stack">
                          {(rounds[curRound]?.matches||[]).map((m,idx)=>{
                            const [id1,id2] = getTeamIdsFromMatch(m);
                            const t1 = computed.find(t=>t.id===id1);
                            const t2 = computed.find(t=>t.id===id2);

                            const fav = m.sidesAssigned ? computed.find(t=>t.id===m.aFavor) : null;
                            const con = m.sidesAssigned ? computed.find(t=>t.id===m.enContra) : null;

                            return(
                              <div key={m.id} style={{border:"1px solid #eee",borderRadius:10,padding:"12px 14px",background:"#fff"}}>
                                <div style={{display:"flex",alignItems:"flex-start",justifyContent:"space-between",gap:10,flexWrap:"wrap",marginBottom:10}}>
                                  <div style={{display:"flex",alignItems:"center",gap:8,flexWrap:"wrap",flex:1}}>
                                    <span className="muted small">Mesa {idx+1}</span>

                                    {m.sidesAssigned ? (
                                      <>
                                        <b>{fav?.name||"‚Äî"}</b>{fav?.school&&<span className="muted small">{fav.school}</span>}
                                        <span className="vs-badge">A FAVOR</span>
                                        <span className="muted">vs</span>
                                        <span className="vs-badge" style={{background:"#1d4ed8"}}>EN CONTRA</span>
                                        <b>{con?.name||"‚Äî"}</b>{con?.school&&<span className="muted small">{con.school}</span>}
                                      </>
                                    ) : (
                                      <>
                                        <b>{t1?.name||"‚Äî"}</b>{t1?.school&&<span className="muted small">{t1.school}</span>}
                                        <span className="muted">vs</span>
                                        <b>{t2?.name||"‚Äî"}</b>{t2?.school&&<span className="muted small">{t2.school}</span>}
                                        <span className="pill orange">Lados por sortear</span>
                                      </>
                                    )}
                                  </div>

                                  <div className="toolbar">
                                    {m.completed?<span className="pill green">‚úì Completado</span>:<span className="pill orange">Pendiente</span>}
                                    <button className="danger sm" onClick={()=>deleteMatch(curRound,idx)}>üóëÔ∏è</button>
                                  </div>
                                </div>

                                {(m.room||m.judges?.length>0)&&(
                                  <div className="muted small" style={{marginBottom:10}}>
                                    {m.room&&<span>üè´ {m.room.name}{m.room.location?` ¬∑ ${m.room.location}`:""}</span>}
                                    {m.judges?.length>0&&<span> ¬∑ üßë‚Äç‚öñÔ∏è {m.judges.map(j=>j.name).join(", ")}</span>}
                                  </div>
                                )}

                                {!m.sidesAssigned && (
                                  <div className="toast" style={{marginBottom:10}}>
                                    <b>Asignar lados</b>
                                    <div className="muted small" style={{marginTop:6}}>
                                      Selecciona qui√©n va <b>A FAVOR</b>. El otro quedar√° <b>EN CONTRA</b>.
                                    </div>
                                    <div style={{marginTop:8, maxWidth:340}}>
                                      <select
                                        value=""
                                        onChange={e=>{
                                          const val = e.target.value || null;
                                          if(val) setMatchSides(curRound, idx, val);
                                        }}
                                      >
                                        <option value="">(elige equipo A FAVOR)</option>
                                        {[id1,id2].filter(Boolean).map(id=>{
                                          const tt = computed.find(x=>x.id===id);
                                          return <option key={id} value={id}>{tt?.name||"‚Äî"}{tt?.school?` ¬∑ ${tt.school}`:""}</option>
                                        })}
                                      </select>
                                    </div>
                                  </div>
                                )}

                                <div style={{display:"flex",gap:16,flexWrap:"wrap",alignItems:"flex-end"}}>
                                  <div>
                                    <div className="muted small" style={{marginBottom:4}}>√çtems A favor / En contra</div>
                                    <div className="score-pair">
                                      <input disabled={!m.sidesAssigned} type="number" style={{width:80}} value={m.favorItems??""} onChange={e=>updMatch(curRound,idx,{favorItems:e.target.value})} placeholder="A fav"/>
                                      <span className="score-sep">/</span>
                                      <input disabled={!m.sidesAssigned} type="number" style={{width:80}} value={m.contraItems??""} onChange={e=>updMatch(curRound,idx,{contraItems:e.target.value})} placeholder="En c."/>
                                    </div>
                                  </div>

                                  <div>
                                    <div className="muted small" style={{marginBottom:4}}>Votos A favor / En contra <span className="pill" style={{fontSize:10}}>opcional</span></div>
                                    <div className="score-pair">
                                      <input disabled={!m.sidesAssigned} type="number" style={{width:80}} value={m.favorVotes??""} onChange={e=>updMatch(curRound,idx,{favorVotes:e.target.value})} placeholder="A fav"/>
                                      <span className="score-sep">/</span>
                                      <input disabled={!m.sidesAssigned} type="number" style={{width:80}} value={m.contraVotes??""} onChange={e=>updMatch(curRound,idx,{contraVotes:e.target.value})} placeholder="En c."/>
                                    </div>
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>

                        <div className="muted small" style={{marginTop:10}}>
                          * "Completado" cuando hay √≠tems en ambos lados y los lados est√°n asignados. Los votos son opcionales.
                        </div>
                      </>
                    )}
                  </>
                )}
              </div>
            )}

            {/* RANKING */}
            {tab==="ranking"&&(
              <div className="card">
                <div className="toolbar" style={{justifyContent:"space-between"}}>
                  <h2 style={{margin:0}}>Clasificaci√≥n</h2>
                  <button className="primary" onClick={exportStandings}>‚¨áÔ∏è Exportar Excel</button>
                </div>

                <div className="spacer"></div>

                {computed.length===0 ? (
                  <div className="muted">A√±ade equipos primero.</div>
                ) : (
                  <>
                    {cfg.tournamentSystem==="grupos" ? (
                      <>
                        <div className="toast" style={{marginBottom:12}}>
                          <b>Ranking por grupos</b>
                          <div className="muted small" style={{marginTop:6}}>
                            La clasificaci√≥n se muestra separada por cada grupo (con el mismo criterio de desempate).
                          </div>
                        </div>

                        <div className="row cols2">
                          {(groups.length ? groups : ensureGroupsExist()).map(g=>{
                            const ids = teams.filter(t=>t.groupId===g.id).map(t=>t.id);
                            const gStand = standings.filter(t=>ids.includes(t.id)).slice().sort(cmp);
                            return (
                              <div key={g.id} className="card" style={{padding:14}}>
                                <div style={{display:"flex",justifyContent:"space-between",gap:10,flexWrap:"wrap",alignItems:"baseline"}}>
                                  <h3 style={{margin:0}}>{g.name}</h3>
                                  <span className="pill">{gStand.length} equipos</span>
                                </div>
                                <div className="spacer"></div>
                                {gStand.length===0 ? (
                                  <div className="muted">Sin equipos asignados.</div>
                                ) : (
                                  <div className="table-wrap">
                                    <table>
                                      <thead><tr><th>Pos</th><th>Equipo</th><th>Instituci√≥n</th><th>Pts</th><th>√çtems</th><th>Votos</th><th>A/E</th></tr></thead>
                                      <tbody>
                                        {gStand.map((t,i)=>(
                                          <tr key={t.id}>
                                            <td><b>{i+1}</b></td>
                                            <td className="wrap">{t.name}</td>
                                            <td className="wrap muted">{t.school}</td>
                                            <td><b>{t.points}</b></td>
                                            <td>{t.itemsWon}</td>
                                            <td>{t.votesWon}</td>
                                            <td>{t.positions?.afavor||0}/{t.positions?.enContra||0}</td>
                                          </tr>
                                        ))}
                                      </tbody>
                                    </table>
                                  </div>
                                )}
                              </div>
                            );
                          })}
                        </div>

                        <div className="hr"></div>

                        <h3 style={{marginTop:0}}>Ranking de oradores (general)</h3>
                        <SpeakerRanking computed={computed}/>
                      </>
                    ) : (
                      <>
                        <h3 style={{marginTop:0}}>Ranking de equipos</h3>
                        <div className="table-wrap"><table>
                          <thead><tr><th>Pos</th><th>Equipo</th><th>Instituci√≥n</th><th>Pts</th><th>√çtems</th><th>Votos</th><th>A/E</th></tr></thead>
                          <tbody>{standings.map((t,i)=>(
                            <tr key={t.id}>
                              <td><b>{i+1}</b></td>
                              <td className="wrap">{t.name}</td>
                              <td className="wrap muted">{t.school}</td>
                              <td><b>{t.points}</b></td>
                              <td>{t.itemsWon}</td>
                              <td>{t.votesWon}</td>
                              <td>{t.positions?.afavor||0}/{t.positions?.enContra||0}</td>
                            </tr>
                          ))}</tbody>
                        </table></div>

                        <div className="hr"></div>
                        <h3>Ranking de oradores</h3>
                        <SpeakerRanking computed={computed}/>
                      </>
                    )}
                  </>
                )}
              </div>
            )}

            <div className="card" style={{padding:"10px 14px"}}>
              <div className="muted small">
                ‚òÅÔ∏è Datos guardados en Supabase (Frankfurt) ‚Äî accesibles desde cualquier dispositivo. ¬∑ Oradores/equipo: <b>{cfg.speakersPerTeam}</b>.
              </div>
            </div>
          </div>
        );
      }

      function SpeakerRanking({computed}){
        const [role,setRole]=useState("TODOS");
        const list=[];
        for(const t of computed) for(const s of (t.speakers||[])) list.push({id:s.id,name:s.name||"",role:s.role||"",points:Number(s.points||0),teamName:t.name,school:t.school});
        const filtered=(role==="TODOS"?list:list.filter(s=>s.role===role)).filter(s=>s.name.trim()).sort((a,b)=>b.points!==a.points?b.points-a.points:a.name.localeCompare(b.name));
        return(
          <div>
            <div style={{marginBottom:10}}><label>Filtrar por rol</label>
              <select value={role} onChange={e=>setRole(e.target.value)} style={{maxWidth:240}}>
                <option value="TODOS">Todos (general)</option>
                {ROLES.map(r=><option key={r.value} value={r.value}>{r.label}</option>)}
              </select>
            </div>
            {filtered.length===0?<div className="muted">No hay oradores con nombre.</div>:(
              <div className="table-wrap"><table>
                <thead><tr><th>Pos</th><th>Orador</th><th>Rol</th><th>Equipo</th><th>Instituci√≥n</th><th className="right">Puntos</th></tr></thead>
                <tbody>{filtered.map((s,i)=>(
                  <tr key={s.id}>
                    <td><b>{i+1}</b></td>
                    <td className="wrap">{s.name}</td>
                    <td className="nowrap">{s.role}</td>
                    <td className="wrap">{s.teamName}</td>
                    <td className="wrap muted">{s.school}</td>
                    <td className="right"><b>{s.points}</b></td>
                  </tr>
                ))}</tbody>
              </table></div>
            )}
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
    </script>
  </body>
</html>
            
